"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PrismaPg: () => PrismaPg
});
module.exports = __toCommonJS(src_exports);

// src/pg.ts
var import_driver_adapter_utils2 = require("@prisma/driver-adapter-utils");
var import_pg2 = __toESM(require("pg"));

// src/conversion.ts
var import_driver_adapter_utils = require("@prisma/driver-adapter-utils");
var import_pg = __toESM(require("pg"));
var import_postgres_array = require("postgres-array");
var { types } = import_pg.default;
var { builtins: ScalarColumnType, getTypeParser, setTypeParser } = types;
var ArrayColumnType = {
  BIT_ARRAY: 1561,
  BOOL_ARRAY: 1e3,
  BYTEA_ARRAY: 1001,
  BPCHAR_ARRAY: 1014,
  CHAR_ARRAY: 1002,
  CIDR_ARRAY: 651,
  DATE_ARRAY: 1182,
  FLOAT4_ARRAY: 1021,
  FLOAT8_ARRAY: 1022,
  INET_ARRAY: 1041,
  INT2_ARRAY: 1005,
  INT4_ARRAY: 1007,
  INT8_ARRAY: 1016,
  JSONB_ARRAY: 3807,
  JSON_ARRAY: 199,
  MONEY_ARRAY: 791,
  NUMERIC_ARRAY: 1231,
  OID_ARRAY: 1028,
  TEXT_ARRAY: 1009,
  TIMESTAMP_ARRAY: 1115,
  TIME_ARRAY: 1183,
  UUID_ARRAY: 2951,
  VARBIT_ARRAY: 1563,
  VARCHAR_ARRAY: 1015,
  XML_ARRAY: 143
};
var _UnsupportedNativeDataType = class _UnsupportedNativeDataType extends Error {
  constructor(code) {
    super();
    this.type = _UnsupportedNativeDataType.typeNames[code] || "Unknown";
    this.message = `Unsupported column type ${this.type}`;
  }
};
// map of type codes to type names
_UnsupportedNativeDataType.typeNames = {
  16: "bool",
  17: "bytea",
  18: "char",
  19: "name",
  20: "int8",
  21: "int2",
  22: "int2vector",
  23: "int4",
  24: "regproc",
  25: "text",
  26: "oid",
  27: "tid",
  28: "xid",
  29: "cid",
  30: "oidvector",
  32: "pg_ddl_command",
  71: "pg_type",
  75: "pg_attribute",
  81: "pg_proc",
  83: "pg_class",
  114: "json",
  142: "xml",
  194: "pg_node_tree",
  269: "table_am_handler",
  325: "index_am_handler",
  600: "point",
  601: "lseg",
  602: "path",
  603: "box",
  604: "polygon",
  628: "line",
  650: "cidr",
  700: "float4",
  701: "float8",
  705: "unknown",
  718: "circle",
  774: "macaddr8",
  790: "money",
  829: "macaddr",
  869: "inet",
  1033: "aclitem",
  1042: "bpchar",
  1043: "varchar",
  1082: "date",
  1083: "time",
  1114: "timestamp",
  1184: "timestamptz",
  1186: "interval",
  1266: "timetz",
  1560: "bit",
  1562: "varbit",
  1700: "numeric",
  1790: "refcursor",
  2202: "regprocedure",
  2203: "regoper",
  2204: "regoperator",
  2205: "regclass",
  2206: "regtype",
  2249: "record",
  2275: "cstring",
  2276: "any",
  2277: "anyarray",
  2278: "void",
  2279: "trigger",
  2280: "language_handler",
  2281: "internal",
  2283: "anyelement",
  2287: "_record",
  2776: "anynonarray",
  2950: "uuid",
  2970: "txid_snapshot",
  3115: "fdw_handler",
  3220: "pg_lsn",
  3310: "tsm_handler",
  3361: "pg_ndistinct",
  3402: "pg_dependencies",
  3500: "anyenum",
  3614: "tsvector",
  3615: "tsquery",
  3642: "gtsvector",
  3734: "regconfig",
  3769: "regdictionary",
  3802: "jsonb",
  3831: "anyrange",
  3838: "event_trigger",
  3904: "int4range",
  3906: "numrange",
  3908: "tsrange",
  3910: "tstzrange",
  3912: "daterange",
  3926: "int8range",
  4072: "jsonpath",
  4089: "regnamespace",
  4096: "regrole",
  4191: "regcollation",
  4451: "int4multirange",
  4532: "nummultirange",
  4533: "tsmultirange",
  4534: "tstzmultirange",
  4535: "datemultirange",
  4536: "int8multirange",
  4537: "anymultirange",
  4538: "anycompatiblemultirange",
  4600: "pg_brin_bloom_summary",
  4601: "pg_brin_minmax_multi_summary",
  5017: "pg_mcv_list",
  5038: "pg_snapshot",
  5069: "xid8",
  5077: "anycompatible",
  5078: "anycompatiblearray",
  5079: "anycompatiblenonarray",
  5080: "anycompatiblerange"
};
var UnsupportedNativeDataType = _UnsupportedNativeDataType;
function fieldToColumnType(fieldTypeId) {
  switch (fieldTypeId) {
    case ScalarColumnType["INT2"]:
    case ScalarColumnType["INT4"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Int32;
    case ScalarColumnType["INT8"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Int64;
    case ScalarColumnType["FLOAT4"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Float;
    case ScalarColumnType["FLOAT8"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Double;
    case ScalarColumnType["BOOL"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Boolean;
    case ScalarColumnType["DATE"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Date;
    case ScalarColumnType["TIME"]:
    case ScalarColumnType["TIMETZ"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Time;
    case ScalarColumnType["TIMESTAMP"]:
    case ScalarColumnType["TIMESTAMPTZ"]:
      return import_driver_adapter_utils.ColumnTypeEnum.DateTime;
    case ScalarColumnType["NUMERIC"]:
    case ScalarColumnType["MONEY"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Numeric;
    case ScalarColumnType["JSON"]:
    case ScalarColumnType["JSONB"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Json;
    case ScalarColumnType["UUID"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Uuid;
    case ScalarColumnType["OID"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Int64;
    case ScalarColumnType["BPCHAR"]:
    case ScalarColumnType["TEXT"]:
    case ScalarColumnType["VARCHAR"]:
    case ScalarColumnType["BIT"]:
    case ScalarColumnType["VARBIT"]:
    case ScalarColumnType["INET"]:
    case ScalarColumnType["CIDR"]:
    case ScalarColumnType["XML"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Text;
    case ScalarColumnType["BYTEA"]:
      return import_driver_adapter_utils.ColumnTypeEnum.Bytes;
    case ArrayColumnType.INT2_ARRAY:
    case ArrayColumnType.INT4_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.Int32Array;
    case ArrayColumnType.FLOAT4_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.FloatArray;
    case ArrayColumnType.FLOAT8_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.DoubleArray;
    case ArrayColumnType.NUMERIC_ARRAY:
    case ArrayColumnType.MONEY_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.NumericArray;
    case ArrayColumnType.BOOL_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.BooleanArray;
    case ArrayColumnType.CHAR_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.CharacterArray;
    case ArrayColumnType.BPCHAR_ARRAY:
    case ArrayColumnType.TEXT_ARRAY:
    case ArrayColumnType.VARCHAR_ARRAY:
    case ArrayColumnType.VARBIT_ARRAY:
    case ArrayColumnType.BIT_ARRAY:
    case ArrayColumnType.INET_ARRAY:
    case ArrayColumnType.CIDR_ARRAY:
    case ArrayColumnType.XML_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.TextArray;
    case ArrayColumnType.DATE_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.DateArray;
    case ArrayColumnType.TIME_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.TimeArray;
    case ArrayColumnType.TIMESTAMP_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.DateTimeArray;
    case ArrayColumnType.JSON_ARRAY:
    case ArrayColumnType.JSONB_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.JsonArray;
    case ArrayColumnType.BYTEA_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.BytesArray;
    case ArrayColumnType.UUID_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.UuidArray;
    case ArrayColumnType.INT8_ARRAY:
    case ArrayColumnType.OID_ARRAY:
      return import_driver_adapter_utils.ColumnTypeEnum.Int64Array;
    default:
      if (fieldTypeId >= 1e4) {
        return import_driver_adapter_utils.ColumnTypeEnum.Text;
      }
      throw new UnsupportedNativeDataType(fieldTypeId);
  }
}
function normalize_array(element_normalizer) {
  return (str) => (0, import_postgres_array.parse)(str, element_normalizer);
}
function normalize_numeric(numeric) {
  return numeric;
}
setTypeParser(ScalarColumnType.NUMERIC, normalize_numeric);
setTypeParser(ArrayColumnType.NUMERIC_ARRAY, normalize_array(normalize_numeric));
function normalize_date(date) {
  return date;
}
function normalize_timestamp(time) {
  return time;
}
function normalize_timestampz(time) {
  return time.split("+")[0];
}
function normalize_time(time) {
  return time;
}
function normalize_timez(time) {
  return time.split("+")[0];
}
setTypeParser(ScalarColumnType.TIME, normalize_time);
setTypeParser(ArrayColumnType.TIME_ARRAY, normalize_array(normalize_time));
setTypeParser(ScalarColumnType.TIMETZ, normalize_timez);
setTypeParser(ScalarColumnType.DATE, normalize_date);
setTypeParser(ArrayColumnType.DATE_ARRAY, normalize_array(normalize_date));
setTypeParser(ScalarColumnType.TIMESTAMP, normalize_timestamp);
setTypeParser(ArrayColumnType.TIMESTAMP_ARRAY, normalize_array(normalize_timestamp));
setTypeParser(ScalarColumnType.TIMESTAMPTZ, normalize_timestampz);
function normalize_money(money) {
  return money.slice(1);
}
setTypeParser(ScalarColumnType.MONEY, normalize_money);
setTypeParser(ArrayColumnType.MONEY_ARRAY, normalize_array(normalize_money));
function toJson(json) {
  return json === "null" ? import_driver_adapter_utils.JsonNullMarker : JSON.parse(json);
}
setTypeParser(ScalarColumnType.JSONB, toJson);
setTypeParser(ScalarColumnType.JSON, toJson);
function encodeBuffer(buffer) {
  return Array.from(new Uint8Array(buffer));
}
var parsePgBytes = getTypeParser(ScalarColumnType.BYTEA);
function convertBytes(serializedBytes) {
  const buffer = parsePgBytes(serializedBytes);
  return encodeBuffer(buffer);
}
setTypeParser(ScalarColumnType.BYTEA, convertBytes);
var parseBytesArray = getTypeParser(ArrayColumnType.BYTEA_ARRAY);
setTypeParser(ArrayColumnType.BYTEA_ARRAY, (serializedBytesArray) => {
  const buffers = parseBytesArray(serializedBytesArray);
  return buffers.map((buf) => buf ? encodeBuffer(buf) : null);
});
function normalizeBit(bit) {
  return bit;
}
setTypeParser(ArrayColumnType.BIT_ARRAY, normalize_array(normalizeBit));
setTypeParser(ArrayColumnType.VARBIT_ARRAY, normalize_array(normalizeBit));
function fixArrayBufferValues(values) {
  for (let i = 0; i < values.length; i++) {
    const list = values[i];
    if (!Array.isArray(list)) {
      continue;
    }
    for (let j = 0; j < list.length; j++) {
      const listItem = list[j];
      if (ArrayBuffer.isView(listItem)) {
        list[j] = Buffer.from(listItem.buffer, listItem.byteOffset, listItem.byteLength);
      }
    }
  }
  return values;
}

// src/pg.ts
var debug = (0, import_driver_adapter_utils2.Debug)("prisma:driver-adapter:pg");
var PgQueryable = class {
  constructor(client) {
    this.client = client;
    this.provider = "postgres";
  }
  /**
   * Execute a query given as SQL, interpolating the given parameters.
   */
  async queryRaw(query) {
    const tag = "[js::query_raw]";
    debug(`${tag} %O`, query);
    const res = await this.performIO(query);
    if (!res.ok) {
      return (0, import_driver_adapter_utils2.err)(res.error);
    }
    const { fields, rows } = res.value;
    const columnNames = fields.map((field) => field.name);
    let columnTypes = [];
    try {
      columnTypes = fields.map((field) => fieldToColumnType(field.dataTypeID));
    } catch (e) {
      if (e instanceof UnsupportedNativeDataType) {
        return (0, import_driver_adapter_utils2.err)({
          kind: "UnsupportedNativeDataType",
          type: e.type
        });
      }
      throw e;
    }
    return (0, import_driver_adapter_utils2.ok)({
      columnNames,
      columnTypes,
      rows
    });
  }
  /**
   * Execute a query given as SQL, interpolating the given parameters and
   * returning the number of affected rows.
   * Note: Queryable expects a u64, but napi.rs only supports u32.
   */
  async executeRaw(query) {
    const tag = "[js::execute_raw]";
    debug(`${tag} %O`, query);
    return (await this.performIO(query)).map(({ rowCount: rowsAffected }) => rowsAffected ?? 0);
  }
  /**
   * Run a query against the database, returning the result set.
   * Should the query fail due to a connection error, the connection is
   * marked as unhealthy.
   */
  async performIO(query) {
    const { sql, args: values } = query;
    try {
      const result = await this.client.query({ text: sql, values: fixArrayBufferValues(values), rowMode: "array" });
      return (0, import_driver_adapter_utils2.ok)(result);
    } catch (e) {
      const error = e;
      debug("Error in performIO: %O", error);
      if (e && e.code) {
        return (0, import_driver_adapter_utils2.err)({
          kind: "Postgres",
          code: e.code,
          severity: e.severity,
          message: e.message,
          detail: e.detail,
          column: e.column,
          hint: e.hint
        });
      }
      throw error;
    }
  }
};
var PgTransaction = class extends PgQueryable {
  constructor(client, options) {
    super(client);
    this.options = options;
  }
  async commit() {
    debug(`[js::commit]`);
    this.client.release();
    return (0, import_driver_adapter_utils2.ok)(void 0);
  }
  async rollback() {
    debug(`[js::rollback]`);
    this.client.release();
    return (0, import_driver_adapter_utils2.ok)(void 0);
  }
};
var PrismaPg = class extends PgQueryable {
  constructor(client, options) {
    if (!(client instanceof import_pg2.default.Pool)) {
      throw new TypeError(`PrismaPg must be initialized with an instance of Pool:
import { Pool } from 'pg'
const pool = new Pool({ connectionString: url })
const adapter = new PrismaPg(pool)
`);
    }
    super(client);
    this.options = options;
  }
  getConnectionInfo() {
    return (0, import_driver_adapter_utils2.ok)({
      schemaName: this.options?.schema
    });
  }
  async startTransaction() {
    const options = {
      usePhantomQuery: false
    };
    const tag = "[js::startTransaction]";
    debug(`${tag} options: %O`, options);
    const connection = await this.client.connect();
    return (0, import_driver_adapter_utils2.ok)(new PgTransaction(connection, options));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PrismaPg
});
